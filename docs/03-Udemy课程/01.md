# 综述

07-DOM MANIPULATION

08-HOW JAVASCRIPT WORKS

09-MODERN OPERATORS(ES6+)

10-FUNCTIONS

11-ARRAYS

12-NUMBERS,DATES,TIMERS

13-ADVANCED DOM

14-OBJECT-ORIENTED JS

15-MAPTY PROJECT

16-ASYNCHRONOUS JS

17-MODERN JS APPLICATIONS

18-FORKIFY PROJECT

19-DEPLOYMENT AND GIT

## VSCODE

Manage-Color Theme-Monokai Pro

Manage-Settings-Auto Save

Manage-Settings-Multi Cursor Modifier

Manage-Settings-Format on Save 

Manage-File Icon Theme-Seti

项目地址：https://github.com/jonasschmedtmann/complete-javascript-course

**What is Javascript**

JAVASCRIPT IS A HIGH-LEVEL,OBJECT-ORIENTED,MULTI-PARADIGM PROGRAMMING LANGUAGE.

多范式

- We don't have to worry about complex stuff like memory management
- Based on objects,for storing most kinds of data
- We can use different styles of programing
- Instruct computer to do things.

# 01-FUNDAMENTALS-PART 1

006-030

**PRIMITIVE DATA TYPES**

- Number
- String
- Boolean
- Undifined
- Null
- Symbol (ES2015)
- BigInt (ES2020)

JavaScript has dynamic typing,Value has type,Not variable!

**OPERATOR PRECEDENCE**

[Operator precedence - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

表情符号：windows+.

**TYPE CONVERSION AND COERCION**

类型转换只需要 Number(),String(),Boolean()即可。

```js
const a = 'I am' + 23 + 'years old'; //数字强转字符串
const b = '23'-'10'-3;//10 减法会自动转数字
const c = '23' / '2' // 11.5
const d = '1' + 1;// 11
```

**Truthy and falsy values**

布尔假值只有5种： 

```js
0 ,'',undefined,null,NaN
```

**statements and expressions**

expressions才是有值的

# 02-FUNDAMENTALS-PART 2

31-51

**Function declarations vs. expressions**

```js
//function declaration
function calcAge1(birthYear){
    return 2037-birthYear;
}
//function expression
const calcAge2 = function (birthYear) {
    return 2037 - birthYear;
}
//arrow function
const calAge3 = birthYear => 2037 - birthYear;
```

![](img\2022-11-21 165629.jpg)



# 03-DEVELOPER SKILLS

53-62

## VSCODE

Extensions-prettier

Manage-default formatter- prettier（格式化的），设置双引号  在根目录下创建文件.prettierrc 

设置代码块快捷键：

Extensions-TODO Highlight

Extensions-Live Server

Node.js-npm install live-server-live-server

# 04-HTML-CSS

63-67

# 05-GUESS-MY-NUMBER

## 71-What's the DOM and DOM Manipulation

DOCUMENT OBJECT MODEL : Structured representation of html documents.Allows JavaScript to access html elements and styles to manipulate then.(Change text,HTML attributes,and even CSS styles)

![](img\Snipaste_2022-11-21_19-52-18.png)



**DOM!==JAVASCRIPT**

DOM操作其实是WEB API，它是用JS编写的库。（有浏览器实现的官方的DOM规范）除了DOM操作，WEB API还包含其他很多，例如计时器、获取API等等

![](img\Snipaste_2022-11-21_19-56-43.png)

## 072-Selecting and Manipulating Elemetns

```html
<p class="message">Start guessing...</p>
<input type="number" class="guess" />
<script>
document.querySelector('.message').textContent = '🎉Correct Number';
console.log('document.querySelector("guess").value');;
</script>
```

## 073-Handling click events

`input`元素获取到的值默认都是字符串

```js
document.querySelector(".check").addEventListener("click", function () {
  const guess = Number(document.querySelector(".guess").value);
});
```

## 074-Implementing the game logic

```js
const secretNumber = Math.trunc(Math.random() * 20) + 1;
```

## 075-Manipulating CSS Styles

```js
//通过这种方式添加样式是内联样式
document.querySelector("body").style.backgroundColor = "#60b347"
```

## 076- Coding challenge #1

完成again按钮的点击功能

## 077-Implementing highscores

完成highscore功能

## 078-Refactoring our code : the dry principle

refactor function displayMessage()

# 06-MODAL

## 079-Project #2 Modal window

## 080-Working with classes

完成点击overlay模块和关闭按钮关闭的功能

## 081-Handling an "ESC" keypress event

Keyboard events are called global events, bacause they do not happen on one specific element.

所以我们都在document上添加事件。

有三种键盘事件：keydown keypress keyup

```js
document.addEventListener('keydown', function (e) {
  if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
    closeModal();
  }
});
```

# 07-PIG-NAME

## 082-Project #3 Pig Game

[Pig Game (pig-game-v2.netlify.app)](https://pig-game-v2.netlify.app/)

## 083-Rolling the dice

## 084-Switch the active player

```js
//如果这个属性有，就remove,没有就add
player0El.classList.toggle("player--active");
```

## 085-Holding current score

## 086-Resetting the game

# 08-Behind the scenes(从93开始)

了解JavaScript的工作原理

## 089-An high-level overview of JavaScript

高级的、基于原型的、面向对象的、多范式的、解释或者及时编译、动态的、单线程的、垃圾回收编程语言，它具有一流的功能和非阻塞事件循环并发模型。

![](img\Snipaste_2022-11-23_17-36-44.png)

In programming,a paradigm is an approach and an overall mindset of structuring our code which will ultimately direct the coding style and technique.

![](img\Snipaste_2022-11-23_17-56-37.png)

![](img\Snipaste_2022-11-23_17-59-52.png)

## 090-The JavaScript engine and runtime

![](img\Snipaste_2022-11-23_23-50-48.png)

引擎是运行JS代码的地方，比如V8引擎，

引擎里有两部分-调用栈和堆



![](img\Snipaste_2022-11-23_23-54-22.png)

JS现在属于编译和解释混用（及时编译）

![](img\Snipaste_2022-11-23_23-58-19.png)



JS运行时（浏览器）

![](img\Snipaste_2022-11-24_00-01-37.png)

JS运行时（Node.js）

![](img\Snipaste_2022-11-24_00-02-39.png)

## 091-Execution contexts and the call stack

global execution context 全局执行上下文，是一个抽象的概念，（Environment in which a piece of JavaScript is executed.Stores all the necessary information for some code to be executed. Such as local variables or arguments passed into a function）JavaScript code always runs inside an execution context.

外面的声明、代码等会第一时间执行，但是函数里面的代码会在它被调用的时候才执行。

任何一个JS项目，无论它多大，都只有一个全局执行环境。函数有自己的execution context.

![](img\Snipaste_2022-11-24_14-36-00.png)



执行上下文里面有以下三项

![](img\Snipaste_2022-11-24_14-40-35.png)

但是箭头函数没有画叉的部分

![](img\Snipaste_2022-11-24_14-43-34.png)



示例执行过程

![](img\Snipaste_2022-11-24_14-50-33.png)

代码按顺序执行，调用函数会生成函数自己的执行上下文，执行完一个上下文，该上下文会从栈中弹出

![](img\Snipaste_2022-11-24_14-52-09.png)

![](img\Snipaste_2022-11-24_15-21-40.png)

最后，Global也会从Stack种弹出。

## 092-Scope and the scope chain

The each execution context has a variable environment,a scope chain and a this keyword.

对于函数而言，scope和variable environment是几乎一样的。

![](img\Snipaste_2022-11-24_15-29-03.png)



三种scope，函数即变量 

![](img\Snipaste_2022-11-24_15-33-25.png)

需要注意的是：let和const是Bolck的，但是var是Function级别的（即如果var变量在Block中声明，外面的函数作用域或者全局作用域是可以访问的）



![](img\Snipaste_2022-11-24_15-50-32.png)

其实就是能访问父亲及祖先的，但是不能访问兄弟及后辈的



the execution context , variable environment, the call stack scope  and the scope chain are all different, but still relevant conceptions.

![](img\Snipaste_2022-11-24_16-10-33.png)



总结

![](img\Snipaste_2022-11-24_16-12-30.png)



## 093-Scoping in practice

变量在scope chain查找的时候，只要查找到了就会停止查找。

## 094-Variable envionment: hoisting and the tdz

![](img\Snipaste_2022-11-24_16-39-06.png)

需要注意的是，函数表达式是否被提升，要看它用的var还是let/const，函数声明会直接被提升。



![](img\Snipaste_2022-11-24_16-43-28.png)

## 095-Hositing and TDZ in practice

访问没有初始化的let变量的报错

![](img\Snipaste_2022-11-24_16-58-15.png)

用const/let声明的函数表达式会报未被初始化的错

![](img\Snipaste_2022-11-24_17-02-51.png)

而用var声明的函数表达式会报 is not a function，因为var变量提升会赋值为undefined

![](img\Snipaste_2022-11-24_17-03-59.png)

同时，用var声明的变量会被加在window对象上。

## 096- The this keyword

每个执行上下文都有自己的this关键字，this关键字不是static.

![](img\Snipaste_2022-11-24_17-18-42.png)

The this keyword will never point to the variable environment of the function.???

## 097-The this keyword in practice

```js
// The this Keyword in Practice
console.log(this); //window对象

const calcAge = function (birthYear) {
  console.log(2037 - birthYear);
  console.log(this);
};
calcAge(1991); // this为undefined 如果不是严格模式，这里会是window

const calcAgeArrow = birthYear => {
  console.log(2037 - birthYear);
  console.log(this);
};
calcAgeArrow(1980); //输出window对象

const jonas = {
  year: 1991,
  calcAge: function () {
    console.log(this);
    console.log(2037 - this.year);
  },
};
jonas.calcAge(); // this为jonas对象

const matilda = {
  year: 2017,
};

matilda.calcAge = jonas.calcAge;
matilda.calcAge(); //this为matilda

const f = jonas.calcAge;
f(); //this为 undefined
```

## 098-Regular functions Vs. arrow functions

建议：不要使用箭头函数作为对象方法

只有常规函数有arguments值，不过arguments在现代JS中不太重要，有新的方法来处理。

```js
///////////////////////////////////////
// Regular Functions vs. Arrow Functions
// var firstName = 'Matilda';

const jonas = {
  firstName: 'Jonas',
  year: 1991,
  calcAge: function () {
    // console.log(this);
    console.log(2037 - this.year);

    // Solution 1
    // const self = this; // self or that
    // const isMillenial = function () {
    //   console.log(self);
    //   console.log(self.year >= 1981 && self.year <= 1996);
    // };

    // Solution 2  ES6之后喜欢用这种方式解决
    const isMillenial = () => {
      console.log(this);
      console.log(this.year >= 1981 && this.year <= 1996);
    };
    isMillenial(); //如果是Solution1 ,因为这里是普通调用，所以this是undefined
  },

  greet: () => {
    console.log(this);
    console.log(`Hey ${this.firstName}`);
  },
};
jonas.greet(); //this为window
jonas.calcAge();

// arguments keyword
const addExpr = function (a, b) {
  console.log(arguments);
  return a + b;
};
addExpr(2, 5);
addExpr(2, 5, 8, 12);

var addArrow = (a, b) => {
  console.log(arguments);
  return a + b;
};
addArrow(2, 5, 8);//报错
```

## 099-Primitives vs. object (primitive vs. reference types)

运行在Stack中表示运行在执行上下文中

![](img\Snipaste_2022-11-24_17-53-35.png)



![](img\Snipaste_2022-11-24_17-56-50.png)

age is equal  to the memory address 0001,which holds the value of 30.

![](img\Snipaste_2022-11-24_17-58-50.png)

![](img\Snipaste_2022-11-24_18-00-47.png)

以下这三个会在之后学习

![](img\Snipaste_2022-11-24_18-01-44.png)

## 100-Primitives vs. objects in practice

```js
const jessica2 = {
  firstName: 'Jessica',
  lastName: 'Williams',
  age: 27,
  family: ['Alice', 'Bob'],
};

const jessicaCopy = Object.assign({}, jessica2);
jessicaCopy.lastName = 'Davis';

jessicaCopy.family.push('Mary');
jessicaCopy.family.push('John');
```

Object.assign(obj1,obj2) 将两个对象的属性合并，是浅拷贝。

深拷贝很复杂，一般使用外部库，比如Lo-Dash

# 09-Data-Structures-Operators

## 103-Destructuring Arrays

数据解构

It is basically a way of unpacking values from an arry or an object into separate variables.

```js
const arr = [2, 3, 4];
const [x, y, z] = arr;
console.log(x, y, z);
```





