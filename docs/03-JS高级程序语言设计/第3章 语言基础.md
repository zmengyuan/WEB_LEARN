本章接下来的内容主要基于 ECMAScript 第 6 版
## 3.1 语法

### 3.1.1 区分大小写
ECMAScript 中一切都区分大小写

### 3.1.2 标识符
所谓标识符，就是变量、函数、属性或函数参数的名称。
- 第一个字符必须是一个字母、下划线（_）或美元符号（$）；
- 剩下的其他字符可以是字母、下划线、美元符号或数字。
- 建议驼峰命名：myCar

JS底层保存标识符时实际上是采用的Unicode编码，所以理论上讲，所有的utf-8中含有的内容都可以作为标识符

### 3.1.3 注释

- 单行`//`
- 多行`/**/`
### 3.1.4 严格模式
ECMAScript 5 增加了严格模式（strict mode）的概念，它其实是一个预处理指令。
```
"use strict";
```

### 3.1.5 语句
以`;`结尾，不强制但是建议加。

## 3.2 关键字与保留字
这些词汇不能用作标识符

## 3.3 变量
ECMAScript 变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有 3 个关键字可以声明变量：var、const 和 let。其中，var 在ECMAScript 的所有版本中都可以使用，而 const 和 let 只能在 ECMAScript 6 及更晚的版本中使用。

### 3.3.1 var 关键字

**1、关于初始化**
<font color = 'red'>只定义`var message`,不初始化的情况下，变量会保存一个特殊值 undefined</font>，var定义的变量可以随时修改值的类型。

**2、关于作用域**
使用 var 操作符定义的变量会成为包含它的函数的局部变量。<font color='red'>如果声明时`message = '消息'`,则代表message是一个全局变量</font>

**3、声明提升**
把所有变量声明都拉到函数作用域的顶部。
```
function foo() { 
 console.log(age); 
 var age = 26; 
} 
foo(); // undefined
```
 以上代码与以下代码一样
```
function foo() { 
 var age; 
 console.log(age); 
 age = 26; 
} 
foo(); // undefined
```
**4、可多次声明**

### 3.3.2 let声明
let 声明的范围是块作用域，而 var 声明的范围是函数作用域
```
if (true) { 
 var name = 'Matt'; 
 console.log(name); // Matt 
} 
console.log(name); // Matt
```
而let则错误
```
if (true) { 
 let age = 26; 
 console.log(age); // 26 
} 
console.log(age); // ReferenceError: age 没有定义
```
**1、暂时性死区**
let声明的变量不会变量提升

**2、全局声明**
与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声明的变量则会）。
```
var name = 'Matt'; 
console.log(window.name); // 'Matt' 
let age = 26; 
console.log(window.age); // undefined
```

**3、条件声明**
不能使用 let 进行条件式声明是件好事，因为条件声明是一种反模式，它让程序变得更难理解。如果你发现自己在使用这个模式，那一定有更好的替代方式。

```
// 假设脚本不确定页面中是否已经声明了同名变量
// 那它可以假设还没有声明过
if (typeof name === 'undefined') { 
let name; 
} 
// name 被限制在 if {} 块的作用域内
// 因此这个赋值形同全局赋值
name = 'Matt';
```
**4、for循环中的let声明**

在 let 出现之前，for 循环定义的迭代变量会渗透到循环体外部：

```
for (var i = 0; i < 5; ++i) { 
 // 循环逻辑 
} 
console.log(i); // 5 
```
改成使用 let 之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部：
```
for (let i = 0; i < 5; ++i) { 
 // 循环逻辑
} 
console.log(i); // ReferenceError: i 没有定义
```
在使用 var 的时候，最常见的问题就是对迭代变量的奇特声明和修改：
```
for (var i = 0; i < 5; ++i) { 
 setTimeout(() => console.log(i), 0) 
} 
// 你可能以为会输出 0、1、2、3、4 
// 实际上会输出 5、5、5、5、5 
```
之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的 i 都是同一个变量，因而输出的都是同一个最终值。而在使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。每个 setTimeout 引用的都是不同的变量实例，所以 console.log 输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。
```
for (let i = 0; i < 5; ++i) { 
 setTimeout(() => console.log(i), 0) 
} 
// 会输出 0、1、2、3、4 
```
这种每次迭代声明一个独立变量实例的行为适用于所有风格的 for 循环，包括 for-in 和 for-of循环。





### 3.3.3 const声明
const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。

const 声明的限制只适用于它指向的变量的引用。换句话说，如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制。

不能用 const 来声明迭代变量（因为迭代变量会自增），不过，如果你只想用 const 声明一个不会被修改的 for 循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。这对 for-of 和 for-in 循环特别有意义
```
for (const i = 0; i < 10; ++i) {} // TypeError：给常量赋值

let i = 0; 
for (const j = 7; i < 5; ++i) { 
 console.log(j); 
} 
// 7, 7, 7, 7, 7 
for (const key in {a: 1, b: 2}) { 
 console.log(key); 
} 
// a, b 
for (const value of [1,2,3,4,5]) { 
 console.log(value); 
} 
// 1, 2, 3, 4, 5
```

### 3.3.4 声明风格及最佳实践
const优先，let次之，不使用var。

## 3.4 数据类型

ECMAScript 有 6 种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String 和Symbol。Symbol（符号）是 ECMAScript 6 新增的。还有一种复杂数据类型叫 Object（对象）。Object 是一种无序名值对的集合

### 3.4.1 typeof操作符
对一个值使用 typeof 操作符会返回下列字符串之一
|  数据类型   | typeof 返回  |
|  ----  | ----  |
| Undefined  | "undefined" |
| Boolean  |  "boolean" |
| String  | "string" |
| Number  | "number" |
| Null  | "object" |
| Object  | "object" |
| Symbol  | "symbol" |
|   | "function" |


### 3.4.2 Undefined 类型
只有一个值，特殊值 undefined，当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了undefined 值。

<font color='red'>注意，typeof 一个未被声明的变量也会返回"undefined"，而不是报错。undefined是一个假值</font>
```
let message; // 这个变量被声明了，只是值为 undefined 
// 确保没有声明过这个变量
// let age 
console.log(typeof message); // "undefined" 
console.log(typeof age); // "undefined"
```
是一个假值
```
let message; // 这个变量被声明了，只是值为 undefined 
// age 没有声明 
if (message) { 
 // 这个块不会执行
} 
if (!message) { 
 // 这个块会执行
} 
if (age) { 
 // 这里会报错
}
```

### 3.4.3 Null 类型
Null 类型同样只有一个值，即特殊值 null。
```
console.log(null == undefined); // true
```
null是一个假值
```
let message = null; 
let age; 
if (message) { 
 // 这个块不会执行
} 
if (!message) { 
 // 这个块会执行
}
```


### 3.4.4 Boolean 类型
虽然布尔值只有两个true和false，但所有其他 ECMAScript 类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的 Boolean()转型函数。
|  数据类型   | 转换为 true 的值  | 转换为 false 的值|
|  ----  | ----  | ----|
| Boolean  | true |false|
| String  | 非空字符串 |""（空字符串）|
| Number  | 非零数值（包括无穷值） |0、NaN（参见后面的相关内容）|
| Object  | 任意对象 |null|
| Undefined  | N/A（不存在） |undefined|


### 3.4.5 Number 类型
Number 类型使用 IEEE 754 格式表示整数和浮点值（在某些语言中也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。

八进制：0 +xx
十六禁止：0x +xx

八进制字面量在严格模式下是无效的，会导致 JavaScript 引擎抛出语法错误。

**注意** 由于 JavaScript 保存数值的方式，实际中可能存在正零（+0）和负零（0）。正零和负零在所有情况下都被认为是等同的，这里特地说明一下。

**1、浮点数**
因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着 0（如 1.0），那它也会被转换为整数。

对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以10 的给定次幂的数值。

```
let floatNum = 3.125e7; // 等于 31250000
3e-17
```

浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。例如，0.1 加 0.2 得到的不是 0.3，而是 0.300 000 000 000 000 04。由于这种微小的舍入错误，导致很难测试特定的浮点值。因此永远不要测试某个特定的浮点值。

**注意** 之所以存在这种舍入错误，是因为使用了 IEEE 754 数值，这种错误并非 ECMAScript所独有。其他使用相同格式的语言也有这个问题。

**2、值的范围**

由于内存的限制，ECMAScript 并不支持表示这个世界上的所有数值。ECMAScript 可以表示的最小数值保存在 Number.MIN_VALUE 中，这个值在多数浏览器中是 5e324；可以表示的最大数值保存在Number.MAX_VALUE 中，这个值在多数浏览器中是 1.797 693 134 862 315 7e+308。如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity（无穷）值。任何无法表示的负数以-Infinity（负无穷大）表示，任何无法表示的正数以 Infinity（正无穷大）表示。

要确定一个值是不是有限大（即介于 JavaScript 能表示的最小值和最大值之间），可以使用 isFinite()函数
```
let result = Number.MAX_VALUE + Number.MAX_VALUE; 
console.log(isFinite(result)); // false
```

**3、NaN**

有一个特殊的数值叫 NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作
失败了（而不是抛出错误）。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执
行。但在 ECMAScript 中，0、+0 或0 相除会返回 NaN：如果分子是非 0 值，分母是有符号 0 或无符号 0，则会返回 Infinity 或-Infinity：

```
console.log(0/0); // NaN 
console.log(-0/+0); // NaN 

console.log(5/0); // Infinity 
console.log(5/-0); // -Infinity
```

任何涉及 NaN 的操作始终返回 NaN,
NaN 不等于包括 NaN 在内的任何值


**注意** 虽然不常见，但 isNaN()可以用于测试对象。此时，首先会调用对象的 valueOf()方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用 toString()方法，并测试其返回值。这通常是 ECMAScript 内置函数和操作符的工作方式，本章后面会讨论。

**4、数值转换**
有 3 个函数可以将非数值转换为数值：Number()、parseInt()和 parseFloat()。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。

Number()转换规则：
- 布尔值，true 转换为 1，false 转换为 0
- 数值，直接返回
- null，返回 0
- undefined，返回 NaN
- 字符串，应用以下规则
  - 如果字符串只包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值
  - 如果字符串包含有效的浮点值格式如"1.1"，则会转换为相应的浮点值
  - 如果字符串包含有效的十六进制格式如"0xf"，则会转换为与该十六进制值对应的十进制整数值
  - 如果是空字符串（不包含字符），则返回 0
  - 如果字符串包含除上述情况之外的其他字符，则返回 NaN
- 对象，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用toString()方法，再按照转换字符串的规则转换。

parseInt()函数更专注于字符串是否包含数值模式
- 只有开头包含数字的才会被识别为数字

parseFloat()函数和parseInt类似，只是parseFloat只解析十进制。

### 3.4.6 String 类型

String（字符串）数据类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号（"）、单引号（'）或反引号（`）标示，因此下面的代码都是合法的：

**1、字符字面量**
\n 回车

**2. 字符串的特点**
ECMAScript 中的字符串是不可变的（immutable）

**3、转换为字符串**
3.1 、toString()方法
可见于数值、布尔值、对象和字符串值。（没错，字符串值也有 toString()方法，该方法只是简单地返回自身的一个副本。）null 和 undefined 值没有 toString()方法。

3.2、String()函数
String()函数遵循如下规则：
- 如果值有 toString()方法，则调用该方法（不传参数）并返回结果
- 如果值是 null，返回"null"
- 如果值是 undefined，返回"undefined"

3.3、拼接空字符串

**4、模板字面量**
ECMAScript 6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串：
```
`模板字面量`
```

**5、字符串插值**
模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。

```
let value = 5; 
let exponent = 'second'; 
// 以前，字符串插值是这样实现的：
let interpolatedString = 
 value + ' to the ' + exponent + ' power is ' + (value * value); 
// 现在，可以用模板字面量这样实现：
let interpolatedTemplateLiteral = 
 `${ value } to the ${ exponent } power is ${ value * value }`; 
console.log(interpolatedString); // 5 to the second power is 25 
console.log(interpolatedTemplateLiteral); // 5 to the second power is 25
```

所有插入的值都会使用 toString()强制转型为字符串，而且任何 JavaScript 表达式都可以用于插值。

**6、模板字面量标签函数**TODO
模板字面量也支持定义标签函数（tag function），而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。
标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为，如下例所示。标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果。这个函数的返回值是对模板字面量求值得到的字符串。

```
const a = `Harry`;
const b = `Potter`;
const c = `Hello`; //定义三个字符串变量
 
function Tag(strings, x, y, z) {
 
//标签函数接收的参数个数取决于引用函数时后面跟的模板字面量中的插值个数，参数个数为（插值个数 + 1）. 本例中参数个数即取决于下文中`${a}${b}, ${c}!`中插值个数，这里面有${a}, ${b}, ${c}三个插值，那么这个标签函数的参数个数即为3 + 1 = 4个. 标签函数中第一个参数都为strings, 即为插值表达式中各插值之间分隔符组成的数组，详见下述
    console.log(strings);
 
//输出[ '', '', ', ', '!' ] 承上，[ '', '', ', ', '!' ] 为表达式`${a}${b}, ${c}!`中各插值之间分隔符组成的数组，我来将各个插值之间的间隔符标注出来以便于理解：`''${a}''${b}', '${c}'!'`. 请注意，第一个插值之前如果没有符号的话，数组中会将第一个间隔符赋值为空值，即为'',两个插值之间如果没有分隔符号，间隔符也会被赋值为数组中的一个空值''.如果分隔符里面有空格，也会一起体现，如数组中的第三个分隔符为', ' 可见逗号后面有一个空格
    console.log(x); 
 
//输出 Harry. x为标签函数接收到的模板字面量`${a}${b}, ${c}!`中的顺序数第一个插值，即为${a}, 也就是`Harry`
    console.log(y);
 
//输出 Hello. y为标签函数接收到的模板字面量`${a}${b}, ${c}!`中的顺序数第二个插值，即为${b}, 也就是`Potter`
    console.log(z);
 
//输出 Hello. z为标签函数接收到的模板字面量`${a}${b}, ${c}!`中的顺序数第三个插值，即为${c}, 也就是`Hello`
 
    return `${c} ${a}, how are you!`;
//标签函数利用读取到的插值，自定义重组并输出新的字面量
}
 
const res = Tag`${a}${b}, ${c}!`;
console.log(res); //输出 Hello Harry, how are you! 
//标签函数利用从`${a}${b}, ${c}!`中读取到的插值，自定义重组并输出新的字面量

```
**7、原始字符串**
使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或 Unicode 字符），而不是被转换后的字符表示

```
console.log(`\u00A9`); // © 
console.log(String.raw`\u00A9`); // \u00A9
```

### 3.4.7 Symbol 类型

Symbol（符号）是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。

**1、符号的基本用法**
```
let sym = Symbol();
```

调用 Symbol()函数时，也可以传入一个字符串参数作为对符号的描述（description），将来可以通过这个字符串来调试代码。但是，这个字符串参数与符号定义或标识完全无关：
```
let fooSymbol = Symbol('foo');
```

符号没有字面量语法，这也是它们发挥作用的关键。按照规范，你只要创建 Symbol()实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性，无论是符号属性还是字符串属性。
```
let genericSymbol = Symbol(); 
console.log(genericSymbol); // Symbol() 
let fooSymbol = Symbol('foo'); 
console.log(fooSymbol); // Symbol(foo);
```

最重要的是，Symbol()函数不能与 new 关键字一起作为构造函数使用。这样做是为了避免创建符号包装对象，


### 3.4.8




## 3.5 操作符

## 3.6 语句

## 3.7 函数

## 3.8 小结